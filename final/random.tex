\section{Random Graph Analysis}\label{sec:random}

This section describes the random graph analysis used in this research.  The testbed, custom graph software, and
the results obtained for the proposed algorithm are discussed.  It finishes with a runtime duration comparison
between the Christofides/Wang, the Zykov, and the proposed algorithm in the target range of \(20\) vertices and
moderate edge density.

\subsection{The Testbed}\label{sec:sub:testbed}

All of the random graph analysis in this research was performed on an Acer Aspire running 64-bit Ubuntu Linux.  The
system contains 8 i7-7780 3.6GHz cores and 20Gb of memory.  The graphing software was custom written in C++.
Although many present day researchers may choose Java or Python, the author feels that the interpretive nature of
those languages combined with unpredictable garbage collection leads to overly inflated and inconsistent results.

The representation of a graph in memory needs to convey the list of vertices, the list of edges, and the connection
matrix.  Graph mutations that change the number of vertices are complex because the connection matrix must be
rebuilt from the altered vertex and edge lists.  Thus, the testbed software assumes that graphs are invariant with
respect to vertex removals and contractions; if vertex removal or contraction is desired then a new graph instance
must be constructed.  Edge additions are innocuous: the new edge can be marked in the connection matrix and
appended to the edge list.

The general layout of a graph instance in memory is shown in \figurename~\ref{fig:layout}.  The vertex and edge
lists are vectors of instances that contain the needed vertex and edge attibutes.  In a particular graph, a vertex
or edge is identified by its position in its list, called its number: vertex numbers are from \(0\) to \(n-1\) and
edge numbers are from \(0\) to \(m-1\).  The connection matrix is a two-dimensional matrix indexed by vertex
numbers: entry \(M[i,j]\) returns a list of edge numbers that can be used to index the edge list to locate the
edges.  If the edge list is empty then the two vertices are not adjacent.  Note that for simple graphs, each edge
list has at most one entry and the connection matrix is symmetric: \(M[i,j]=M[j,i]\).

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[node distance=0in]
    \node (c) [draw, rectangle, minimum height=1in, minimum width=1.5in] at (0,0)
          {\begin{tabular}{c} connection \\ matrix \end{tabular}};
    \node (v) [draw, rectangle, minimum height=1in, minimum width=1.5in, below=of c]
          {\begin{tabular}{c} vertex \\ list \end{tabular}};
    \node (e) [draw, rectangle, minimum height=1in, minimum width=1.5in, below=of v]
          {\begin{tabular}{c} edge \\ list \end{tabular}};
    \node (t) [draw, rectangle, minimum height=1in, minimum width=1.5in, below=of e]
          {\begin{tabular}{c} vertex \\ lookup \\ table \end{tabular}};
  \end{tikzpicture}
  \caption{Graph layout in memory.}
  \label{fig:layout}
\end{figure}

One of the complications of graph mutations is that the vertex and edge numbers change when a new graph is
constructed.  This is why graph mutations result in new instances.  In order to be able to identify vertices across
graph mutations, each vertex is assigned a unique vertex ID when a new graph is created.  Vertices keep their
original IDs across graph mutations, although their numbers may change.  Thus, edges in the edge list refer to
their endpoint vertices by ID and a vertex ID to vertex number lookup table is included as part of the graph
schema.

Contracted vertices are assigned new vertex IDs when created; however, graph algorithms like the proposed algorithm
may need to remember the original vertices that were contracted.  To support this, each vertex instance includes a
list of contracted vertex IDs.  When two non-contracted vertices are contracted, the new contracted vertex has a
contracted vertex ID list consisting of the original two vertex IDs.  When contracted vertices are are contracted,
their contracted vertex ID lists are concatenated.  Thus, contracted vertex ID lists contain only vertex IDs from
the original graph.

One of the most important parameters used by graph algorithms is vertex degree.  As was explained in
\sectionname~\ref{sec:sub:adjacency}, the degree of vertex \(v_i\) can be calculated by summing the \(i^{th}\) row
or column in the connection matrix.  So that degrees do not have to be recalculated each time they are used, the
connection matrix precalculates vertex degrees upon graph creation: each time an edge is added the degrees of the
endpoint vertices are incremented.  The minimum and maximum degrees for a graph still need to be recalculated each
time, so algorithms should cache those values once fetched.

Since new graphs may be created many times during the execution of a graph algorithm, graph construction must be
as efficient as possible.  The testbed software creates a new graph using the following steps:
\begin{enumerate}
\item Each of the \(n\) vertices are added to the new vertex list and a corresponding entry is added to the vertex
  ID to number lookup table.
\item An empty \(n\times n\) connection matrix is allocated with all vertex degrees set to \(0\).
\item Each edge is added to the edge list.  The endpoint vertex IDs are found in the lookup table and the edge is
  registered in the connection matrix, which increments the degrees for the endpoint vertices.
\end{enumerate}

Thus, new graph creation has runtime complexity \(\BO(n+m)\).

\subsection{Runtime Complexity Results}\label{sec:sub:runtime}

\begin{figure}[H]
  \centering
  \includegraphics[width=5in]{qz_steps}
  \caption{Proposed algorithm mean number of steps.}
  \label{fig:qzsteps}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=5in]{qz_runtime}
  \caption{Proposed algorithm runtime complexity.}
  \label{fig:qzruntime}
\end{figure}

\subsection{Bounding Test Results}\label{sec:sub:bounding}

\begin{figure}[H]
  \centering
  \includegraphics[width=5in]{qz_match}
  \caption{Proposed algorithm lower/upper bound matching test.}
  \label{fig:qzmatch}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=5in]{qz_edges}
  \caption{Proposed algorithm maximum edge threshold test.}
  \label{fig:qzedges}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=5in]{qz_small}
  \caption{Proposed algorithm small degree vertex test.}
  \label{fig:qzsmall}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=5in]{qz_subset}
  \caption{Proposed algorithm neighborhood subset test.}
  \label{fig:qzsubset}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=5in]{qz_common}
  \caption{Proposed algorithm minimum common neighbors upper bound test.}
  \label{fig:qzsubset}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=5in]{qz_bounding}
  \caption{Proposed algorithm bounding test.}
  \label{fig:qzbound}
\end{figure}

\subsection{Runtime Duration Results}
